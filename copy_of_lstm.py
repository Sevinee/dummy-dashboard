# -*- coding: utf-8 -*-
"""Copy of LSTM

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ju5CWLOS5DOZYaFgbnM4N28UXKQpJ2G7
"""

# ===============================
# Library
# ===============================
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import requests
import warnings
warnings.filterwarnings("ignore")
from datetime import datetime
from math import sqrt
from numpy import concatenate
from matplotlib import pyplot
from pandas import read_excel
from pandas import DataFrame
from pandas import concat
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import mean_squared_error
from keras.models import Sequential,load_model
from keras.layers import Dense
from keras.layers import LSTM

# ===============================
# 1. Ambil Data Crude Oil, Emas, dan Kurs USD/IDR
# ===============================

crude_oil = pd.read_excel("/content/Data SLM.xlsx", sheet_name="Crude Oil")
gold = pd.read_excel("/content/Data SLM.xlsx", sheet_name="Gold")
usd_idr = pd.read_excel("/content/Data SLM.xlsx", sheet_name="USDIDR")

# Hapus kolom selain "Date" dan "Close"
crude_oil = crude_oil[["Date", "Close"]]
gold = gold[["Date", "Close"]]
usd_idr = usd_idr[["Date", "Close"]]

# Ubah nama kolom
crude_oil = crude_oil.rename(columns = {'Close': 'Crude Oil'})
gold = gold.rename(columns = {'Close': 'Gold'})
usd_idr = usd_idr.rename(columns = {'Close': 'USD/IDR'})

# Hapus koma dan ubah menjadi data tipe numeric
usd_idr['USD/IDR'] = usd_idr['USD/IDR'].astype(str).str.replace(',', '')
usd_idr['USD/IDR'] = pd.to_numeric(usd_idr['USD/IDR'], errors='coerce')

# Set 'Date' sebagai index untuk setiap dataframe
crude_oil = crude_oil.set_index('Date')
gold = gold.set_index('Date')
usd_idr = usd_idr.set_index('Date')

# Gabungkan dataframe
df_market = usd_idr.join(gold, how = 'outer', lsuffix = '_crude', rsuffix = '_gold')
df_market = df_market.join(crude_oil, how = 'outer', rsuffix = '_usd')
df_market.dropna(inplace=True) # Hilangkan baris yang memiliki NaN
df_market = df_market.reset_index() # Reset index

# Cek tipe data setiap kolom
df_market.dtypes

# 2. Ambil Data Inflasi dari World Bank API
# ===============================

url = "https://api.worldbank.org/v2/country/ID/indicator/FP.CPI.TOTL.ZG?format=json&per_page=100"
response = requests.get(url).json()

# Validasi response
if isinstance(response, list) and len(response) > 1:
    inflation_data = [
        {"year": int(entry["date"]), "inflation": entry["value"]}
        for entry in response[1]
        if entry["value"] is not None
    ]
else:
    inflation_data = []

df_inflation = pd.DataFrame(inflation_data).sort_values("year")
df_inflation.reset_index(drop = True, inplace = True) # Reset index

# Ekspansi inflasi tahunan ke inflasi bulanan
monthly_inflation = pd.DataFrame()

for _, row in df_inflation.iterrows():
    year = str(int(row['year']))  # Cast to string
    months = pd.date_range(f"{year}-01-01", f"{year}-12-31", freq='ME')
    monthly_df = pd.DataFrame({
        "date": months,
        "inflation": row['inflation'] / 12
    })
    monthly_inflation = pd.concat([monthly_inflation, monthly_df], ignore_index=True)

monthly_inflation.set_index("date", inplace=True)
monthly_inflation.index = pd.to_datetime(monthly_inflation.index)

# ===============================
# 3. Gabungkan Semua Data
# ===============================

# Buat kolom bulan untuk join
df_market['Month'] = df_market['Date'].dt.to_period('M').dt.to_timestamp()

# Pastikan index monthly_inflation adalah awal bulan
monthly_inflation.index = monthly_inflation.index.to_period('M').to_timestamp()
monthly_inflation.index.name = 'Month'

# Gabungkan berdasarkan bulan
df_final = df_market.merge(monthly_inflation, on = 'Month', how = 'left')

# Hapus kolom bantu
df_final.drop(columns = 'Month', inplace=True)

# Isi nilai NaN dengan data sebelumnya (forward fill)
df_final['inflation'] = df_final['inflation'].ffill()

# Set Date menjadi index
df_final.set_index('Date', inplace=True)

# Plot untuk setiap fitur
plot_columns = {
    'Gold': 'Gold Price',
    'Crude Oil': 'Crude Oil',
    'USD/IDR': 'Exchange Rate (USD/IDR)',
    'inflation': 'Inflation'
}

fig, axes = plt.subplots(2, 2, figsize=(14, 8))
axes = axes.flatten()

for i, (col, ylabel) in enumerate(plot_columns.items()):
    axes[i].plot(df_final.index, df_final[col])
    axes[i].set_title(f'{ylabel} Over Time')
    axes[i].set_xlabel('Date')
    axes[i].set_ylabel(ylabel)
    axes[i].grid(True)
    axes[i].tick_params(axis='x', rotation=45)

plt.tight_layout()
plt.show()

df_final

values = df_final.values
values

# Ubah data time series menjadi supervised learning
def series_to_supervised(data, n_in, n_out, dropnan=True):
    n_vars = 1 if type(data) is list else data.shape[1]
    df = DataFrame(data)
    cols, names = list(), list()
    # input sequence (t-n, ... t-1)
    for i in range(n_in, 0, -1):
        cols.append(df.shift(i))
        names += [('var%d(t-%d)' % (j+1, i)) for j in range(n_vars)]
    # forecast sequence (t, t+1, ... t+n)
    for i in range(0, n_out):
        cols.append(df.shift(-i))
        if i == 0:
            names += [('var%d(t)' % (j+1)) for j in range(n_vars)]
        else:
            names += [('var%d(t+%d)' % (j+1, i)) for j in range(n_vars)]
    # put it all together
    agg = concat(cols, axis = 1)
    agg.columns = names
    # drop rows with NaN values
    if dropnan:
        agg.dropna(inplace=True)
    return agg

# Memastikan semua data bertipe float
values = values.astype('float32')

# Normalisasi fitur
scaler = MinMaxScaler(feature_range=(0, 1))
scaled = scaler.fit_transform(values)
scaled

# DF supervised learning
reframed = series_to_supervised(scaled, 1, 1)
reframed

# Drop kolom yang tidak diperlukan
reframed.drop(reframed.columns[[5, 6, 7]], axis = 1, inplace = True)
print(reframed.head())

# Split data
values = reframed.values
train, test = train_test_split(values, test_size = 0.2, shuffle = False)

# Split menjadi input dan outputs
train_X, train_y = train[:, :-1], train[:, -1]
test_X, test_y = test[:, :-1], test[:, -1]

# Membentuk ulang input menjadi 3D [samples, timesteps, features]
train_X = train_X.reshape((train_X.shape[0], 1, train_X.shape[1]))
test_X = test_X.reshape((test_X.shape[0], 1, test_X.shape[1]))
print(train_X.shape, train_y.shape, test_X.shape, test_y.shape)

# Design network
model = Sequential()
model.add(LSTM(20, input_shape = (train_X.shape[1], train_X.shape[2])))
model.add(Dense(1))
model.compile(loss='mse', optimizer='adam')

# fit network
history = model.fit(train_X, train_y, epochs = 500, batch_size = 72, validation_data = (test_X, test_y), verbose = 2, shuffle=False)
model.save('./savedModel.keras')

# plot history
pyplot.plot(history.history['loss'], label='train')
pyplot.plot(history.history['val_loss'], label='test')
pyplot.legend()
pyplot.show()

# Prediksi
yhat = model.predict(test_X)
test_X = test_X.reshape((test_X.shape[0], test_X.shape[2]))

# Plot
pyplot.plot(test_y, label = "original")
pyplot.plot(yhat, label = "predict")
pyplot.legend(loc = "best")

# Invert skala untuk prediksi
inv_yhat = concatenate((yhat, test_X[:, 1:]), axis = 1)
inv_yhat = scaler.inverse_transform(inv_yhat)
inv_yhat = inv_yhat[:,0]

print("Price for last 5 days: ")
print(inv_yhat[-5:])

# invert skala untuk aktual
test_y = test_y.reshape((len(test_y), 1))
inv_y = concatenate((test_y, test_X[:, 1:]), axis = 1)
inv_y = scaler.inverse_transform(inv_y)
inv_y = inv_y[:,0]

print(inv_y)

# modeling untuk seluruh data

import pandas as pd
import numpy as np
from datetime import datetime, timedelta

# Buat tanggal mulai dari hari setelah data terakhir
start_date = datetime.strptime("2025-06-10", "%Y-%m-%d")  # <- Ubah sesuai data kamu
forecast_dates = [start_date + timedelta(days=i) for i in range(len(inv_yhat))]

# Buat DataFrame
df_result = pd.DataFrame({
    'Tanggal': forecast_dates,
    'Actual': inv_y,
    'Predicted': inv_yhat
})

# Simpan ke Excel
df_result.to_excel('hasil_prediksi.xlsx', index=False)

from google.colab import files
files.download('hasil_prediksi.xlsx')